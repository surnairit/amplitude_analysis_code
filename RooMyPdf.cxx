/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooMyPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include <iostream>
#include <cmath>
#include <algorithm>
#include <complex>

ClassImp(RooMyPdf) 

 RooMyPdf::RooMyPdf(const char *name, const char *title, 
//                        RooAbsReal& _x,
//                        RooAbsReal& _alpha
//        RooAbsReal& _rooB0_mass,
        RooAbsReal& _rooKPi_mass,
        RooAbsReal& _rooJpsiPi_mass,
//        RooAbsReal& _rooJpsi_mass,
//        RooAbsReal& _rooB0_3mom,
//        RooAbsReal& _rooTheta_Kstar,
        RooAbsReal& _rooPhi,
        RooAbsReal& _rooTheta_Jpsi
//        RooAbsReal& _rooPhi
                        ) :
   RooAbsPdf(name,title), 
//   x("x","x",this,_x),
//   alpha("alpha","alpha",this,_alpha)

//        rooB0_mass("rooB0_mass","rooB0_mass",this,_rooB0_mass),
        rooKPi_mass("rooKPi_mass","rooKPi_mass",this,_rooKPi_mass),
        rooJpsiPi_mass("rooJpsiPi_mass","rooJpsiPi_mass",this,_rooJpsiPi_mass),
//        rooJpsi_mass("rooJpsi_mass","rooJpsi_mass",this,_rooJpsi_mass),
//        rooB0_3mom("rooB0_3mom","rooB0_3mom",this,_rooB0_3mom),
//        rooTheta_Kstar("rooTheta_Kstar","rooTheta_Kstar",this,_rooTheta_Kstar),
        rooPhi("rooPhi","rooPhi",this,_rooPhi),
        rooTheta_Jpsi("rooTheta_Jpsi","rooTheta_Jpsi",this,_rooTheta_Jpsi)
//        rooPhi("rooPhi","rooPhi",this,_rooPhi)

 { 
 } 


 RooMyPdf::RooMyPdf(const RooMyPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
//   x("x",this,other.x),
//   alpha("alpha",this,other.alpha)
//        rooB0_mass("rooB0_mass",this,other.rooB0_mass),
        rooKPi_mass("rooKPi_mass",this,other.rooKPi_mass),
        rooJpsiPi_mass("rooJpsiPi_mass",this,other.rooJpsiPi_mass),
//        rooJpsi_mass("rooJpsi_mass",this,other.rooJpsi_mass),
//        rooB0_3mom("rooB0_3mom",this,other.rooB0_3mom),
//        rooTheta_Kstar("rooTheta_Kstar",this,other.rooTheta_Kstar),
        rooPhi("rooPhi",this,other.rooPhi),
        rooTheta_Jpsi("rooTheta_Jpsi",this,other.rooTheta_Jpsi)
//        rooPhi("rooPhi",this,other.rooPhi)

 {
 
 } 



 Double_t RooMyPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
//   return sqrt(abs(x*alpha))+0.1 ;
//   return RooMyPdf::get_signal_density(rooB0_mass,rooKPi_mass,rooJpsi_mass,rooB0_3mom,rooTheta_Kstar,rooPhi,rooTheta_Jpsi);
   if ( (rooKPi_mass < mK+mPi) || (rooKPi_mass > (mB - mJpsi) ) || (rooJpsiPi_mass < mJpsi+mPi) || (rooJpsiPi_mass > (mB - mK) ) ) { return 0.0; }
   else
//   { return RooMyPdf::get_signal_density(rooKPi_mass,rooTheta_Kstar,rooPhi,rooTheta_Jpsi); }
   { return RooMyPdf::get_signal_density(rooKPi_mass,rooJpsiPi_mass,rooPhi,rooTheta_Jpsi); }

 }



//================ Decay Momentum ====================
// Momentum in 2-particle decay : m0->m1+m2

double RooMyPdf::sq_calc(double x,double y, double z) const
{
    return pow(x,2)+pow(y,2)+pow(z,2)-2.0*x*y-2.0*x*z-2.0*y*z; // corr sign
}

double RooMyPdf::dec2mm (double m0, double m1, double m2) const
{
    double temp = sq_calc(m0*m0,m1*m1,m2*m2);
    if (temp >= 0) {
    return sqrt(temp)/(2.0*m0);
    }
    else {
    return 0.0;
    }
}
//================ Decay Momentum ====================


//================ Blatt-Weisskopf Form Factors ======
// l = spin
// q = momentum from "dec2mm"
// q0 = momentum from "dec2mm" with PDG mass
// r = meson radial parameter (hadron scale)
double RooMyPdf::bwff(int l, double q, double q0, double r) const
{
    double z = r*r*q*q;
    double z0 = r*r*q0*q0;
    double f;
    //########### spin 0 ###############
    if (l == 0) {
        f = 1.0;
    }
    //########### spin 1 ###############
    if (l == 1) {
        f = sqrt((1+z0)/(1+z));
    }
    //########### spin 2 ###############
    if (l == 2) {
        f = sqrt((z0*z0+3.0*z0+9.0)/(z*z+3.0*z+9.0));
    }
    //########### spin 3 ###############
    if (l == 3) {
        f = sqrt((z0*z0*z0+6.0*z0*z0+45.0*z0+225.0)/(z*z*z+6.0*z*z+45.0*z+225.0));
    }
    //########### spin 4 ###############
    if (l == 4) {
        f = sqrt((z0*z0*z0*z0+10.0*z0*z0*z0+135.0*z0*z0+1575.0*z0+11025.0)/(z*z*z*z+10.0*z*z*z+135.0*z*z+1575.0*z+11025.0)); // from evtgen code
    }    
    return f;
}
//================ Blatt-Weisskopf Form Factors ======

//================ Breit-Wigner Amplitude ============
// m0 = resonance mass (pdg)
// w0 = width (pdg)
// m = invariant mass of two daughters of the resonance
// m_d1, m_d2 = daughter masses
// l = relative angular momentum
// f = BW form factor
// q = momentum from "dec2mm"
// q0 = momentum from "dec2mm" with PDG mass

//complex<double> RooMyPdf::bwamp(double m0,double w0,double m,double m_d1,double m_d2,int l,double f,double q0,double q) const
complex<double> RooMyPdf::bwamp(double m0,double w0,double m,int l,double f,double q0,double q) const
{
    double width = w0*pow((q/q0),2*l+1)*(m0/m)*f*f;
//    cout << "width for " << m0 << " = " << width << endl;
    double deno = (m0*m0 - m*m)*(m0*m0 - m*m) + m0*m0*width*width;
//    cout << "deno for " << m0 << " = " << deno << endl;
    double rl = f*pow((q/m),l)*(m0*m0 - m*m)/deno;
    double imag = f*pow((q/m),l)*m0*width/deno;
    complex<double> val(rl,imag);
    complex<double> val2((m0*m0 - m*m)/deno,m0*width/deno);
//    cout << "just BW for " << m0 << " = " << val2 << endl;
//    cout << "blatt weiskopf for "<< m0 << " = " << f << endl;
//    cout << "power (resonance) for "<< m0 << " = " << pow((q/m),l) << endl;
//    cout << "  " << endl;
    return val;
}

//================ Jacobi Polynomial =================
//Jacobi polynomial - order n
double RooMyPdf::jacobi_Pn (int n, double a, double b, double x) const
{
    
    if (n==0){
        return 1.0;
    }
    else if (n==1){
        return  0.5 * (a - b + (a + b + 2.0)*x);
    }
    else {
        
        double p0, p1, a1, a2, a3, a4, p2=0.0;
        int i;
        p0 = 1.0;
        p1 = 0.5 * (a - b + (a + b + 2)*x);
        
        for(i=1; i<n; ++i){
            a1 = 2.0*(i+1.0)*(i+a+b+1.0)*(2.0*i+a+b);
            a2 = (2.0*i+a+b+1.0)*(a*a-b*b);
            a3 = (2.0*i+a+b)*(2.0*i+a+b+1.0)*(2.0*i+a+b+2.0);
            a4 = 2.0*(i+a)*(i+b)*(2.0*i+a+b+2.0);
            p2 = 1.0/a1*( (a2 + a3*x)*p1 - a4*p0);
            
            p0 = p1;
            p1 = p2;
        }
        
        return p2;
    }
    
}
//================ Jacobi Polynomial =================


//================ factorial =========================
int RooMyPdf::Factorial(int x) const
{
    if (x==0) { return 1; }
    return (x == 1 ? x : x * Factorial(x - 1));
}
//================ factorial =========================


//================ combination =======================
int RooMyPdf::Combination(int n, int r) const
{
  return (Factorial(n)) / ((Factorial(n-r)) * Factorial(r));
}
//================ combination =======================



//================ wigner d calculations =============

double RooMyPdf::wigner_d (int j, int m1, int m2, double theta ) const
{
    int array[] = {j+m1, j-m1, j+m2, j-m2};
    int k = *min_element(array,array+4) ;
//    cout << "k : " << k << endl;
    int a = abs(m1-m2);//fabs?
//    cout << "a : " << a << endl;
    double lambda; //int - not working due to pow overload resolution
    if (k == j+m1) { lambda = 0;}
    else if (k == j-m1) { lambda = m1-m2;}
    else if (k == j+m2) { lambda = m1-m2;}
    else if (k == j-m2) { lambda = 0;}
//    cout << "lambda : " << lambda << endl;
    int b = 2*j-2*k-a;
//    cout << "b : " << b << endl;
    double value = pow(-1,lambda) * pow(Combination(2*j-k,k+a),0.5) * pow(Combination(k+b,b),-0.5) * pow(sin(0.5*theta),a) * pow(cos(0.5*theta),b) * jacobi_Pn(k,a,b,cos(theta));
//    cout << "jacobi : " << jacobi_Pn(k,a,b,cos(theta)) << endl;
    return value;
 
}
//================ wigner d calculations =============


//================ phase space =======================
double RooMyPdf::PHSP(double mKPicalc) const
{
    return dec2mm(mB,mKPicalc,mJpsi) * dec2mm(mKPicalc,mK,mPi) ;
}
//================ phase space =======================

//================ costheta_k ===========================
double RooMyPdf::costhetaK(double mKPicalc, double mJpsiPicalc) const
{
    double m2KPi = mKPicalc*mKPicalc;
    double m2JpsiPi = mJpsiPicalc*mJpsiPicalc;

    double num = 0.5*(m2KPi)*(m2B+m2K-m2JpsiPi) - 0.25*(m2B-m2Jpsi+m2KPi) * (m2KPi-m2Pi+m2K);
    double denom2 = ( 0.25*( pow((m2B-m2Jpsi+m2KPi),2) ) - (m2KPi*m2B) ) * ( 0.25*( pow((m2KPi-m2Pi+m2K),2) ) - (m2KPi*m2K) );
    double denom = sqrt(denom2);  

    double costheta_k = num/denom;
//    return TMath::ACos(costheta_k);
    return costheta_k;
}
//================ costheta_k ===========================

//================ Signal Density Calculation ========
//pB = B0 3-momentum
//double RooMyPdf::get_signal_density (double mBcalc, double mKPicalc, double mJpsicalc, double pB, double theta_k, double phi, double theta_jpsi ) const
//double RooMyPdf::get_signal_density (double mKPicalc, double theta_k, double phi, double theta_jpsi ) const
double RooMyPdf::get_signal_density (double mKPicalc, double mJpsiPicalc, double phi, double theta_jpsi ) const
{ // signal density begin

    if (fabs(costhetaK(mKPicalc,mJpsiPicalc))>1 ) { 
	return 0.0;
	}

    else { // cos theta K* physical
//    cout << "cos theta K* : " << costhetaK(mKPicalc,mJpsiPicalc) << endl;
    double theta_k = TMath::ACos(costhetaK(mKPicalc,mJpsiPicalc));

    double q = dec2mm(mB,mKPicalc,mJpsi); 
//    double qB = pB/mB;
    double qB  = q/mB;
    double qB2 = qB*qB;
    double qB3 = qB2*qB;
    double qB4 = qB3*qB;
    double qB5 = qB4*qB;
    //================ Amplitudes for the different K resonances===========
    // mKPi = K-Pi inv mass calculated from data
    double qK = dec2mm(mKPicalc,mK,mPi);
    
    //############## K0*(800) ###################
    double q0_800 = dec2mm(mB,mK0_800,mJpsi);
    double qK0_800 = dec2mm(mK0_800,mK,mPi);
    double fK0_800 = bwff(0,qK,qK0_800,rR);
//    complex<double> a_K0_800 = bwamp(mK0_800,wK0_800,mKPicalc,mK,mPi,0,fK0_800,qK0_800,qK);
    complex<double> a_K0_800 = bwamp(mK0_800,wK0_800,mKPicalc,0,fK0_800,qK0_800,qK);
    a_K0_800 = a_K0_800  *  qB * bwff(1,q,q0_800,rB); //
//    cout<< "a_K0_800 pure bw with ff : " << a_K0_800 << endl;
//    cout << "  " << endl ;
    
    //############## K*(892) ###################
    double qK892 = dec2mm(mK892,mK,mPi);
    double fK892 = bwff(1,qK,qK892,rR);
//    complex<double> a_K_892 = bwamp(mK892,wK892,mKPicalc,mK,mPi,1,fK892,qK892,qK);
    complex<double> a_K_892 = bwamp(mK892,wK892,mKPicalc,1,fK892,qK892,qK);
//    cout<< "a_K_892 pure bw with ff : " << a_K_892 << endl;
//    cout << "  " << endl ;
    
    //############## K*(1410) ###################
    double qK1410 = dec2mm(mK1410,mK,mPi);
    double fK1410 = bwff(1,qK,qK1410,rR);
//    complex<double> a_K_1410 = bwamp(mK1410,wK1410,mKPicalc,mK,mPi,1,fK1410,qK1410,qK);
    complex<double> a_K_1410 = bwamp(mK1410,wK1410,mKPicalc,1,fK1410,qK1410,qK);
//    cout<< "a_K_1410 pure bw with ff : " << a_K_1410 << endl;
//    cout << "  " << endl ;
    
    //############## K0*(1430) ###################
    double q0_1430 = dec2mm(mB,mK0_1430,mJpsi);
    double qK0_1430 = dec2mm(mK0_1430,mK,mPi);
    double fK0_1430 = bwff(0,qK,qK0_1430,rR); // check spin
//    complex<double> a_K0_1430 = bwamp(mK0_1430,wK0_1430,mKPicalc,mK,mPi,0,fK0_1430,qK0_1430,qK);
    complex<double> a_K0_1430 = bwamp(mK0_1430,wK0_1430,mKPicalc,0,fK0_1430,qK0_1430,qK);
    a_K0_1430 = a_K0_1430 * qB * bwff(1,q,q0_1430,rB);
//    cout<< "a_K0_1430 pure bw with ff : " << a_K0_1430 << endl;
//    cout << "  " << endl ;
    
    //############## K2*(1430) ###################
    double q2_1430 = dec2mm(mB,mK2_1430,mJpsi);
    double qK2_1430 = dec2mm(mK2_1430,mK,mPi);
    double fK2_1430 = bwff(2,qK,qK2_1430,rR);
//    complex<double> a_K2_1430 = bwamp(mK2_1430,wK2_1430,mKPicalc,mK,mPi,2,fK2_1430,qK2_1430,qK);
    complex<double> a_K2_1430 = bwamp(mK2_1430,wK2_1430,mKPicalc,2,fK2_1430,qK2_1430,qK);
    a_K2_1430 = a_K2_1430 * qB * bwff(1,q,q2_1430,rB);
//    cout<< "a_K2_1430 pure bw with ff : " << a_K2_1430 << endl;
//    cout << "  " << endl ;
    
    //############## K*(1680) ###################
    double qK1680 = dec2mm(mK1680,mK,mPi);
    double fK1680 = bwff(1,qK,qK1680,rR);
//    complex<double> a_K_1680 = bwamp(mK1680,wK1680,mKPicalc,mK,mPi,1,fK1680,qK1680,qK);
    complex<double> a_K_1680 = bwamp(mK1680,wK1680,mKPicalc,1,fK1680,qK1680,qK);
    
    //############## K3*(1780) ###################
    double q3_1780 = dec2mm(mB,mK3_1780,mJpsi);
    double qK3_1780 = dec2mm(mK3_1780,mK,mPi);
    double fK3_1780 = bwff(3,qK,qK3_1780,rR);
//    complex<double> a_K3_1780 = bwamp(mK3_1780,wK3_1780,mKPicalc,mK,mPi,3,fK3_1780,qK3_1780,qK);
    complex<double> a_K3_1780 = bwamp(mK3_1780,wK3_1780,mKPicalc,3,fK3_1780,qK3_1780,qK);
    a_K3_1780 = a_K3_1780 * qB2 * bwff(2,q,q3_1780,rB);
    
    //############## K0*(1950) ###################
    double q0_1950 = dec2mm(mB,mK0_1950,mJpsi);
    double qK0_1950 = dec2mm(mK0_1950,mK,mPi);
    double fK0_1950 = bwff(0,qK,qK0_1950,rR); // check spin
//    complex<double> a_K0_1950 = bwamp(mK0_1950,wK0_1950,mKPicalc,mK,mPi,0,fK0_1950,qK0_1950,qK);
    complex<double> a_K0_1950 = bwamp(mK0_1950,wK0_1950,mKPicalc,0,fK0_1950,qK0_1950,qK);
    a_K0_1950 = a_K0_1950 * qB * bwff(1,q,q0_1950,rB);
    
    //############## K2*(1980) ###################
    double q2_1980 = dec2mm(mB,mK2_1980,mJpsi);
    double qK2_1980 = dec2mm(mK2_1980,mK,mPi);
    double fK2_1980 = bwff(2,qK,qK2_1980,rR);
//    complex<double> a_K2_1980 = bwamp(mK2_1980,wK2_1980,mKPicalc,mK,mPi,2,fK2_1980,qK2_1980,qK);
    complex<double> a_K2_1980 = bwamp(mK2_1980,wK2_1980,mKPicalc,2,fK2_1980,qK2_1980,qK);
    a_K2_1980 = a_K2_1980 * qB * bwff(1,q,q2_1980,rB);
    
    //############## K4*(2045) ###################
    double q4_2045 = dec2mm(mB,mK4_2045,mJpsi);
    double qK4_2045 = dec2mm(mK4_2045,mK,mPi);
    double fK4_2045 = bwff(4,qK,qK4_2045,rR);
//    complex<double> a_K4_2045 = bwamp(mK4_2045,wK4_2045,mKPicalc,mK,mPi,4,fK4_2045,qK4_2045,qK);
    complex<double> a_K4_2045 = bwamp(mK4_2045,wK4_2045,mKPicalc,4,fK4_2045,qK4_2045,qK);
    a_K4_2045 = a_K4_2045 * qB3 * bwff(3,q,q4_2045,rB);
    
    //############## K5*(2380) ###################
    double q5_2380 = dec2mm(mB,mK5_2380,mJpsi);
    double qK5_2380 = dec2mm(mK5_2380,mK,mPi);
    double fK5_2380 = bwff(4,qK,qK5_2380,rR);
    complex<double> a_K5_2380 = bwamp(mK5_2380,wK5_2380,mKPicalc,4,fK5_2380,qK5_2380,qK);
    a_K5_2380 = a_K5_2380 * qB4 * bwff(4,q,q5_2380,rB);


//******************** lepton pair helicity minus 1**************
    complex<double> index_minus1_m1(0.0,-1*phi);
    complex<double> a_K_892_minus1_m1 = a_K_892*wigner_d(1,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, -1,-1 : " << wigner_d(1,-1,0,theta_k)<< "  " << wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << " exp * wigner for k_892, -1,-1 : " << exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << "  " << endl;
    complex<double> a_K_1410_minus1_m1 = a_K_1410*wigner_d(1,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_1410, -1,-1 : " << wigner_d(1,-1,0,theta_k)<< "  " << wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_1410, -1,-1 : " << exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << "  " << endl;
    complex<double> a_K2_1430_minus1_m1 = a_K2_1430*wigner_d(2,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
    complex<double> a_K3_1780_minus1_m1 = a_K3_1780*wigner_d(3,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
    complex<double> a_K4_2045_minus1_m1 = a_K4_2045*wigner_d(4,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
    complex<double> a_K5_2380_minus1_m1 = a_K5_2380*wigner_d(5,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k2_1430, -1,-1 : " << wigner_d(2,-1,0,theta_k)<< "  " << wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k2_1430, -1,-1 : " << exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi) << endl;
//    cout << "  " << endl;
    complex<double> a_K_1680_minus1_m1 = a_K_1680*wigner_d(1,-1,0,theta_k)*exp(index_minus1_m1)*wigner_d(1,-1,-1,theta_jpsi);
    
    complex<double> index_zero_m1(0.0,0.0);
//    cout << "K892 wigner_thetaK* : " << wigner_d(1,0,0,theta_k) << " exp(0) x wigner_thetaPsi  : " << exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi) << endl ;
    complex<double> a_K_892_zero_m1 = a_K_892*wigner_d(1,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, 0,-1 : " << wigner_d(1,0,0,theta_k)<< "  " << wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_892, -1,-1 : " << exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "a_K_892_zero_m1 : " << a_K_892_zero_m1 << endl ;
//    cout << "  " << endl;
    
    complex<double> a_K_1410_zero_m1 = a_K_1410*wigner_d(1,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_1410, 0,-1 : " << wigner_d(1,0,0,theta_k)<< "  " << wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_1410, 0,-1 : " << exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "  " << endl;
    complex<double> a_K2_1430_zero_m1 = a_K2_1430*wigner_d(2,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
    complex<double> a_K3_1780_zero_m1 = a_K3_1780*wigner_d(3,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
    complex<double> a_K4_2045_zero_m1 = a_K4_2045*wigner_d(4,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
    complex<double> a_K5_2380_zero_m1 = a_K5_2380*wigner_d(5,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k2_1430, 0,-1 : " << wigner_d(2,0,0,theta_k)<< "  " << wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k2_1430, 0,-1 : " << exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "  " << endl;

    complex<double> a_K_1680_zero_m1 = a_K_1680*wigner_d(1,0,0,theta_k)*exp(index_zero_m1)*wigner_d(1,0,-1,theta_jpsi);
    
    complex<double> a_K0_800_m1 = a_K0_800*wigner_d(0,0,0,theta_k)*wigner_d(1,0,-1,theta_jpsi);
    complex<double> a_K0_1430_m1 = a_K0_1430*wigner_d(0,0,0,theta_k)*wigner_d(1,0,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_800, 0,-1 : " << wigner_d(0,0,0,theta_k)<< " " <<wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << " a_K0_800_m1 : " << a_K0_800_m1 << endl;
//    cout << " " << endl ;
//    cout << "wigner1, wigner2 for k0_1430, 0,-1 : " << wigner_d(0,0,0,theta_k)<< " " <<wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << " a_K0_1430_m1 : " << a_K0_1430_m1 << endl;
//    cout << " " << endl ;
    
    
//    cout << "wigner1, wigner2 for k800 : " << wigner_d(0,0,0,theta_k)<< "  " << wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "wigner * wigner for k800 : " << wigner_d(0,0,0,theta_k) * wigner_d(1,0,-1,theta_jpsi) << endl;
//    cout << "  " << endl;
//    cout << "angle : " << theta_jpsi << endl;
    
    complex<double> index_plus1_m1(0.0,phi);
//    cout << "K892 wigner_thetaK* : " << wigner_d(1,1,0,theta_k) << " exp(iphi) x wigner_thetaPsi  : " << exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi) << endl ;
    complex<double> a_K_892_plus1_m1 = a_K_892*wigner_d(1,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, 1,-1 : " << wigner_d(1,1,0,theta_k)<< "  " << wigner_d(1,1,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_892, 1,-1 : " << exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi) << endl;
//    cout << "a_K_892_plus1_m1 : " << a_K_892_plus1_m1 << endl ;
//    cout << "  " << endl;
    
    complex<double> a_K_1410_plus1_m1 = a_K_1410*wigner_d(1,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
    complex<double> a_K2_1430_plus1_m1 = a_K2_1430*wigner_d(2,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
    complex<double> a_K3_1780_plus1_m1 = a_K3_1780*wigner_d(3,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
    complex<double> a_K4_2045_plus1_m1 = a_K4_2045*wigner_d(4,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
    complex<double> a_K5_2380_plus1_m1 = a_K5_2380*wigner_d(5,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
//    cout << "wigner1, wigner2 for k2_1430, 1,-1 : " << wigner_d(2,1,0,theta_k)<< "  " << wigner_d(1,1,-1,theta_jpsi) << endl;
//    cout << "exp * wigner for k2_1430, 1,-1 : " << exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi) << endl;
//    cout << "Leo's value : " << -7.4994e-17 * complex<double>(0.484456,-0.123702)<< endl;
//    cout << "  " << endl;
    complex<double> a_K_1680_plus1_m1 = a_K_1680*wigner_d(1,1,0,theta_k)*exp(index_plus1_m1)*wigner_d(1,1,-1,theta_jpsi);
    
//******************** lepton pair helicity plus 1**************
    complex<double> index_minus1_p1(0.0,-1*phi);
    complex<double> a_K_892_minus1_p1 = a_K_892*wigner_d(1,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, -1,1 : " << wigner_d(1,-1,0,theta_k)<< "  " << wigner_d(1,-1,1,theta_jpsi) << endl;
//    cout << " exp * wigner for k_892, -1,1 : " << exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi) << endl;
//    cout << " a_K_892_minus1_p1 : " << a_K_892_minus1_p1 << endl;
//    cout << " " << endl;
    complex<double> a_K_1410_minus1_p1 = a_K_1410*wigner_d(1,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    complex<double> a_K2_1430_minus1_p1 = a_K2_1430*wigner_d(2,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    complex<double> a_K3_1780_minus1_p1 = a_K3_1780*wigner_d(3,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    complex<double> a_K4_2045_minus1_p1 = a_K4_2045*wigner_d(4,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    complex<double> a_K5_2380_minus1_p1 = a_K5_2380*wigner_d(5,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    complex<double> a_K_1680_minus1_p1 = a_K_1680*wigner_d(1,-1,0,theta_k)*exp(index_minus1_p1)*wigner_d(1,-1,1,theta_jpsi);
    
    complex<double> index_zero_p1(0.0,0.0);
    complex<double> a_K_892_zero_p1 = a_K_892*wigner_d(1,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, 0,1 : " << wigner_d(1,0,0,theta_k)<< "  " << wigner_d(1,0,1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_892, 0,1 : " << exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi) << endl;
//    cout << " a_K_892_zero_p1 : " << a_K_892_zero_p1 << endl;
//    cout << "  " << endl;

    complex<double> a_K_1410_zero_p1 = a_K_1410*wigner_d(1,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    complex<double> a_K2_1430_zero_p1 = a_K2_1430*wigner_d(2,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    complex<double> a_K3_1780_zero_p1 = a_K3_1780*wigner_d(3,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    complex<double> a_K4_2045_zero_p1 = a_K4_2045*wigner_d(4,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    complex<double> a_K5_2380_zero_p1 = a_K5_2380*wigner_d(5,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    complex<double> a_K_1680_zero_p1 = a_K_1680*wigner_d(1,0,0,theta_k)*exp(index_zero_p1)*wigner_d(1,0,1,theta_jpsi);
    
    complex<double> a_K0_800_p1 = a_K0_800*wigner_d(0,0,0,theta_k)*wigner_d(1,0,1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_800, 0,1 : " << wigner_d(0,0,0,theta_k)<< " " <<wigner_d(1,0,1,theta_jpsi) << endl;
//    cout << " a_K0_800_p1 : " << a_K0_800_p1 << endl;
    complex<double> a_K0_1430_p1 = a_K0_1430*wigner_d(0,0,0,theta_k)*wigner_d(1,0,1,theta_jpsi);
//    cout << "wigner1, wigner2 for k0_1430, 0,1 : " << wigner_d(0,0,0,theta_k)<< " " <<wigner_d(1,0,1,theta_jpsi) << endl;
//    cout << " a_K0_1430_p1 : " << a_K0_1430_p1 << endl;
//    cout << " " << endl ;
    
    complex<double> index_plus1_p1(0.0,phi);
    complex<double> a_K_892_plus1_p1 = a_K_892*wigner_d(1,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
//    cout << "wigner1, wigner2 for k_892, 1,1 : " << wigner_d(1,1,0,theta_k)<< "  " << wigner_d(1,1,1,theta_jpsi) << endl;
//    cout << "exp * wigner for k_892, 1,1 : " << exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi) << endl;
//    cout << " a_K_892_plus1_p1 : " << a_K_892_plus1_p1 << endl;
//    cout << "  " << endl;

    complex<double> a_K_1410_plus1_p1 = a_K_1410*wigner_d(1,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    complex<double> a_K2_1430_plus1_p1 = a_K2_1430*wigner_d(2,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    complex<double> a_K3_1780_plus1_p1 = a_K3_1780*wigner_d(3,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    complex<double> a_K4_2045_plus1_p1 = a_K4_2045*wigner_d(4,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    complex<double> a_K5_2380_plus1_p1 = a_K5_2380*wigner_d(5,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    complex<double> a_K_1680_plus1_p1 = a_K_1680*wigner_d(1,1,0,theta_k)*exp(index_plus1_p1)*wigner_d(1,1,1,theta_jpsi);
    
//******************* helicity phase ***************************

complex<double> hK0_800(1.12*TMath::Cos(2.3),1.12*TMath::Sin(2.3));
//cout << "hK0_800 : " << hK0_800 << endl;
//cout << "  " << endl;

complex<double> h0K892(1*TMath::Cos(0),1*TMath::Sin(0));
complex<double> hp1K892(0.844*TMath::Cos(3.14),0.844*TMath::Sin(3.14));
complex<double> hm1K892(0.196*TMath::Cos(-1.7),0.196*TMath::Sin(-1.7));

//cout << "h0K892 : " << h0K892 << endl;
//cout << "hp1K892 : " << hp1K892 << endl;
//cout << "hm1K892 : " << hm1K892 << endl;
//cout << "  " << endl;

complex<double> h0K1410(0.119*TMath::Cos(0.81),0.119*TMath::Sin(0.81));
complex<double> hp1K1410(0.123*TMath::Cos(-1.04),0.123*TMath::Sin(-1.04));
complex<double> hm1K1410(0.036*TMath::Cos(0.67),0.036*TMath::Sin(0.67));

complex<double> hK0_1430(0.89*TMath::Cos(-2.17),0.89*TMath::Sin(-2.17));
//cout << "hK0_1430 : " << hK0_1430 << endl;
//cout << "  " << endl;

complex<double> h0K2_1430(4.66*TMath::Cos(-0.32),4.66*TMath::Sin(-0.32));
complex<double> hp1K2_1430(4.65*TMath::Cos(-3.05),4.65*TMath::Sin(-3.05));
complex<double> hm1K2_1430(1.26*TMath::Cos(-1.92),1.26*TMath::Sin(-1.92));

complex<double> h0K1680(0.139*TMath::Cos(-2.46),0.139*TMath::Sin(-2.46));
complex<double> hp1K1680(0.082*TMath::Cos(-2.85),0.082*TMath::Sin(-2.85));
complex<double> hm1K1680(0.161*TMath::Cos(1.88),0.161*TMath::Sin(1.88));

complex<double> h0K3_1780(16.8*TMath::Cos(-1.43),16.8*TMath::Sin(-1.43));
complex<double> hp1K3_1780(19.1*TMath::Cos(2.03),19.1*TMath::Sin(2.03));
complex<double> hm1K3_1780(10.2*TMath::Cos(1.55),10.2*TMath::Sin(1.55));

complex<double> hK0_1950(0.241*TMath::Cos(-2.39),0.241*TMath::Sin(-2.39));

complex<double> h0K2_1980(4.53*TMath::Cos(-0.26),4.53*TMath::Sin(-0.26));
complex<double> hp1K2_1980(3.78*TMath::Cos(3.08),3.78*TMath::Sin(3.08));
complex<double> hm1K2_1980(3.51*TMath::Cos(2.63),3.51*TMath::Sin(2.63));

complex<double> h0K4_2045(590*TMath::Cos(-2.66),590*TMath::Sin(-2.66));
complex<double> hp1K4_2045(676*TMath::Cos(0.06),676*TMath::Sin(0.06));
complex<double> hm1K4_2045(103*TMath::Cos(-1.03),103*TMath::Sin(-1.03));


//    double val = pow(abs(//a_K_892_minus1_m1 //* exp(helphase_index_K_892_minus1)
                        //+a_K_892_zero_m1   //* exp(helphase_index_K_892_zero)
                        //+a_K_892_plus1_m1  //* exp(helphase_index_K_892_plus1)
//                        hK0_800*a_K0_800 + hK892*a_K_892 + hK1410*a_K_1410 + hK0_1430*a_K0_1430 + hK2_1430*a_K2_1430
//                        + hK1680*a_K_1680 + hK3_1780*a_K3_1780 + hK0_1950*a_K0_1950 + hK2_1980*a_K2_1980 + hK4_2045*a_K4_2045
                        //a_K0_800 + a_K_892 + a_K_1410 + a_K0_1430 + a_K2_1430 + a_K_1680 + a_K3_1780 + a_K0_1950 + a_K2_1980 + a_K4_2045
                        //+a_K0_800
//                        a_K0_1430_m1
                        //a_K0_1430
                        //+a_K_892_minus1_p1 //* exp(helphase_index_K_892_minus1)
                        //+a_K_892_zero_p1   //* exp(helphase_index_K_892_zero)
                        //+a_K_892_plus1_p1
                        
                        //+ a_K0_1430_p1
//                        ), 2); //* exp(helphase_index_K_892_plus1)),2);
    
    double val_m1 = pow(abs(
    
                        //a_K_892_minus1_m1 * hm1K892
                        //+a_K_892_zero_m1 * h0K892
                        //+a_K_892_plus1_m1 * hp1K892
                        
                        //+a_K_1410_minus1_m1 * hm1K1410
                        //+a_K_1410_zero_m1 * h0K1410
                        //+a_K_1410_plus1_m1 * hp1K1410
                        
                        a_K2_1430_minus1_m1 //* hm1K2_1430
                        +a_K2_1430_zero_m1 //* h0K2_1430
                        +a_K2_1430_plus1_m1 //* hp1K2_1430

//                        a_K3_1780_minus1_m1 //* hm1K3_1780
//                        +a_K3_1780_zero_m1 //* h0K3_1780
//                        +a_K3_1780_plus1_m1 //* hp1K3_1780

//                        a_K4_2045_minus1_m1 //* hm1K4_2045
//                        +a_K4_2045_zero_m1 //* h0K4_2045
//                        +a_K4_2045_plus1_m1 //* hp1K4_2045

//                        a_K5_2380_minus1_m1 //* hm1K5_2380
//                        +a_K5_2380_zero_m1 //* h0K5_2380
//                        +a_K5_2380_plus1_m1 //* hp1K5_2380

     
                        //+a_K_1680_minus1_m1 * hm1K1680
                        //+a_K_1680_zero_m1 * h0K1680
                        //+a_K_1680_plus1_m1 * hp1K1680
                        
                        //+a_K0_800_m1 * hK0_800
                        //+a_K0_1430_m1 * hK0_1430
                        ), 2);
// cout << " a_K_892_minus1_m1 * hm1K892 : " << a_K_892_minus1_m1 * hm1K892 << endl;
// cout << " a_K_892_zero_m1 * h0K892 : " << a_K_892_zero_m1 * h0K892 << endl;
// cout << " a_K_892_plus1_m1 * hp1K892 : " << a_K_892_plus1_m1 * hp1K892 << endl;
// cout << " ME sum K_892 -1 : " << a_K_892_minus1_m1 * hm1K892 + a_K_892_zero_m1 * h0K892 + a_K_892_plus1_m1 * hp1K892 << endl;
// cout << " a_K_892_minus1_m1  : " << a_K_892_minus1_m1  << endl;
// cout << " a_K_892_zero_m1  : " << a_K_892_zero_m1  << endl;
// cout << " a_K_892_plus1_m1  : " << a_K_892_plus1_m1  << endl;
 
// cout << "  " << endl;
 

    double val_p1 = pow(abs(
    
                        //a_K_892_minus1_p1 * hm1K892
                        //+a_K_892_zero_p1 * h0K892
                        //+a_K_892_plus1_p1 * hp1K892
                        
                        //+a_K_1410_minus1_p1 * hm1K1410
                        //+a_K_1410_zero_p1 * h0K1410
                        //+a_K_1410_plus1_p1 * hp1K1410
                        
                        a_K2_1430_minus1_p1 //* hm1K2_1430
                        +a_K2_1430_zero_p1 //* h0K2_1430
                        +a_K2_1430_plus1_p1 //* hp1K2_1430

//                        a_K3_1780_minus1_p1 //* hm1K3_1780
//                        +a_K3_1780_zero_p1 //* h0K3_1780
//                        +a_K3_1780_plus1_p1 //* hp1K3_1780

//                        a_K4_2045_minus1_p1 //* hm1K4_2045
//                        +a_K4_2045_zero_p1 //* h0K4_2045
//                        +a_K4_2045_plus1_p1 //* hp1K4_2045

//                        a_K5_2380_minus1_p1 //* hm1K5_2380
//                        +a_K5_2380_zero_p1 //* h0K5_2380
//                        +a_K5_2380_plus1_p1 //* hp1K5_2380
    
                        //+a_K_1680_minus1_p1 * hm1K1680
                        //+a_K_1680_zero_p1 * h0K1680
                        //+a_K_1680_plus1_p1 * hp1K1680
     
                        //+a_K0_800_p1 * hK0_800
                        //+a_K0_1430_p1 * hK0_1430
                        ), 2);

// cout << " a_K_892_minus1_p1 * hm1K892 : " << a_K_892_minus1_m1 * hm1K892 << endl;
// cout << " a_K_892_zero_p1 * h0K892 : " << a_K_892_zero_p1 * h0K892 << endl;
// cout << " a_K_892_plus1_p1 * hp1K892 : " << a_K_892_plus1_p1 * hp1K892 << endl;
// cout << " ME sum K_892 +1 : " << a_K_892_minus1_p1 * hm1K892 + a_K_892_zero_p1 * h0K892 + a_K_892_plus1_p1 * hp1K892 << endl;
// cout << " a_K_892_minus1_p1  : " << a_K_892_minus1_p1  << endl;
// cout << " a_K_892_zero_p1  : " << a_K_892_zero_p1  << endl;
// cout << " a_K_892_plus1_p1  : " << a_K_892_plus1_p1  << endl;
// cout << " " << endl;
    


    double k892_p1 = pow(abs(
                        a_K_892_minus1_p1 * hm1K892
                        +a_K_892_zero_p1 * h0K892
                        +a_K_892_plus1_p1 * hp1K892
                        ), 2);
    
    double k892_m1 = pow(abs(
                        a_K_892_minus1_m1 * hm1K892
                        +a_K_892_zero_m1 * h0K892
                        +a_K_892_plus1_m1 * hp1K892
                        ), 2);
   

    double k800_m1 = pow(abs(
                        a_K0_800_m1 * hK0_800
                        ), 2);
    double k800_p1 = pow(abs(
                        a_K0_800_p1 * hK0_800
                        ), 2);
//cout << " ME sum K_800 -1 : " << a_K0_800_m1 * hK0_800 << endl;
//cout << " ME sum K_800 +1 : " << a_K0_800_p1 * hK0_800 << endl;
//cout << " " << endl;
    double k1410_p1 = pow(abs(
                        a_K_1410_minus1_p1 * hm1K1410
                        +a_K_1410_zero_p1 * h0K1410
                        +a_K_1410_plus1_p1 * hp1K1410
                        ), 2);
    
    double k1410_m1 = pow(abs(
                        a_K_1410_minus1_m1 * hm1K1410
                        +a_K_1410_zero_m1 * h0K1410
                        +a_K_1410_plus1_m1 * hp1K1410
                        ), 2);
//cout << " ME sum K_1410 -1 : " << a_K_1410_minus1_m1 * hm1K1410+a_K_1410_zero_m1 * h0K1410+a_K_1410_plus1_m1 * hp1K1410 << endl;
//cout << " ME sum K_1410 +1 : " << a_K_1410_minus1_p1 * hm1K1410+a_K_1410_zero_p1 * h0K1410+a_K_1410_plus1_p1 * hp1K1410 << endl;
//cout << " " << endl;


    double k0_1430_p1 = pow(abs(
                        a_K0_1430_m1 * hK0_1430
                        ), 2);
    
    double k0_1430_m1 = pow(abs(
                        a_K0_1430_p1 * hK0_1430
                        ), 2);
//cout << " ME sum K0_1430 -1 : " << a_K0_1430_m1 * hK0_1430 << endl;
//cout << " ME sum K0_1430 +1 : " << a_K0_1430_p1 * hK0_1430 << endl;
//cout << " " << endl;
    
    
    double k2_1430_m1 = pow(abs(
                        a_K2_1430_minus1_m1 * hm1K2_1430
                        +a_K2_1430_zero_m1 * h0K2_1430
                        +a_K2_1430_plus1_m1 * hp1K2_1430
                        ), 2);
    
    double k2_1430_p1 = pow(abs(
                        a_K2_1430_minus1_p1 * hm1K2_1430
                        +a_K2_1430_zero_p1 * h0K2_1430
                        +a_K2_1430_plus1_p1 * hp1K2_1430
                        ), 2);
//cout << " ME sum K2_1430 -1 : " << a_K2_1430_minus1_m1 * hm1K2_1430+a_K2_1430_zero_m1 * h0K2_1430+a_K2_1430_plus1_m1 * hp1K2_1430 << endl;
//cout << " ME sum K2_1430 +1 : " << a_K2_1430_minus1_p1 * hm1K2_1430+a_K2_1430_zero_p1 * h0K2_1430+a_K2_1430_plus1_p1 * hp1K2_1430 << endl;
//cout << " " << endl;
   
   
//cout << "sq sum K892 m1: " << k892_m1 << endl;
//cout << "sq sum K892 p1: " << k892_p1 << endl;
//cout << " " << endl;
//cout << "sq sum K800 m1: " << k800_m1 << endl;
//cout << "sq sum K800 p1: " << k800_p1 << endl;
//cout << " " << endl;
//cout << "sq sum K1410 m1: " << k1410_m1 << endl;
//cout << "sq sum K1410 p1: " << k1410_p1 << endl;
//cout << " " << endl;
//cout << "sq sum K0_1430 m1: " << k0_1430_m1 << endl;
//cout << "sq sum K0_1430 p1: " << k0_1430_p1 << endl;
//cout << " " << endl;
//cout << "sq sum K2_1430 m1: " << k2_1430_m1 << endl;
//cout << "sq sum K2_1430 p1: " << k2_1430_p1 << endl;
//cout << " " << endl;
//cout << "sq sum 5 K* m1: " << val_m1 << endl;
//cout << "sq sum 5 K* p1: " << val_p1 << endl;
//cout << " " << endl;
//cout << " sum 5 K* m1 : " << a_K_892_minus1_m1 * hm1K892+a_K_892_zero_m1 * h0K892+a_K_892_plus1_m1 * hp1K892+a_K_1410_minus1_m1 * hm1K1410+a_K_1410_zero_m1 * h0K1410+a_K_1410_plus1_m1 * hp1K1410+a_K2_1430_minus1_m1 * hm1K2_1430+a_K2_1430_zero_m1 * h0K2_1430+a_K2_1430_plus1_m1 * hp1K2_1430+a_K0_800_m1 * hK0_800+a_K0_1430_m1 * hK0_1430  << endl;
    
//cout << " sum 5 K* p1 : " << a_K_892_minus1_p1 * hm1K892+a_K_892_zero_p1 * h0K892+a_K_892_plus1_p1 * hp1K892+a_K_1410_minus1_p1 * hm1K1410+a_K_1410_zero_p1 * h0K1410+a_K_1410_plus1_p1 * hp1K1410+a_K2_1430_minus1_p1 * hm1K2_1430+a_K2_1430_zero_p1 * h0K2_1430+a_K2_1430_plus1_p1 * hp1K2_1430+a_K0_800_p1 * hK0_800+a_K0_1430_p1 * hK0_1430 << endl;
//cout << " " << endl;


//    return pow(abs(a_K0_800_m1 * hK0_800),2) ;
//    return (pow(abs(wigner_d(0,0,0,theta_k)*wigner_d(1,0,-1,theta_jpsi)*hK0_800),2));
//    return temp_m1;

//cout << "PHSP : " << PHSP(mKPicalc) << endl;
//    return (val_m1+val_p1) * PHSP(mKPicalc) ;
//      return ( pow(abs(a_K2_1430),2) ) * PHSP(mKPicalc);
      return (k2_1430_m1 + k2_1430_p1) * PHSP(mKPicalc);

} // cos theta K* physical

//================ Amplitudes for the different K resonances===========

}// signal density end
//================ Signal Density Calculation ========



